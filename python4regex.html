<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Reference guide for regular expressions in Python</title>
<link rel="stylesheet" href="./styles.css" />
</head>
<body>

<h1>Reference guide for regular expressions in Python</h1>

<h2>Matching text patterns</h2>
<button class="collapsible">Matching text literally</button>
<div class="content">
  <p><strong>Use a string literal (concatenate ordinary characters)</strong></p>
  <p>Case sensitive, e.g. reg matches “reg” in “regex”,  but not in “Regex”
The re.I (re.IGNORECASE) flag makes matching case-insensitive in a searching function.
</p>
</div>
<button class="collapsible">Matching any single alphanumeric character</button>
<div class="content">
  <p><strong>Use \w</strong></p>
  <p>\w is shorthand for [a-zA-Z0-9_]. 
\W is the opposite of \w, shorthand for [^a-zA-Z0-9_].
</p>
</div>
<button class="collapsible">Matching any single digit</button>
<div class="content">
  <p><strong>Use \d</strong></p>
  <p>\d is shorthand for [0-9]. \D is the opposite of \d, shorthand for [^0-9].</p>
</div>
<button class="collapsible">Matching a whitespace</button>
<div class="content">
  <p><strong>Use \s</strong></p>
  <p>\s is shorthand for [ \r\n\t\f\v]. \S is the opposite, matching what is not whitespace: [^ \r\n\t\f\v].</p>
</div>
<button class="collapsible">Matching any character</button>
<div class="content">
  <p><strong>. (dot) matches any single character (including a space), except the newline (\n) character</strong></p>
  <p>Using the  re.S (re.DOTALL) flag with a searching function forces the dot to match a new line character.
</p>
</div>
<button class="collapsible">Matching a character with a set of options</button>
<div class="content">
  <p><strong>Put the set of matching options in square brackets: [...].
Any of the characters enclosed within the square brackets [ ] is a matching option for a single character from the input text.
</strong></p>
  <p>e.g. defen[cs]e matches both “defence” and “defense”. 
[^...] is the opposite, matching anything but what is in the set e.g <[^>]> matches an html tag with any content. 
An hyphen (-) can indicate a range of characters in a set e.g. [a-fA-F], [0-5].
</p>
</div>
<button class="collapsible">Matching a literal hyphen literally when in a set
</button>
<div class="content">
  <p><strong>Place the hyphen in first or last position in the set, or escape it.
</strong></p>
  <p>e.g. [-abc], [abc-], [ab\-c].</p>
</div>
<button class="collapsible">Matching a special character literally when in a set</button>
<div class="content">
  <p><strong>Special characters lose their special meaning inside sets.</strong></p>
  <p>e.g. the special characters in the set [().,*+?|] match themselves literally.</p>
</div>
<button class="collapsible">Matching a special character literally when outside a set</button>
<div class="content">
  <p><strong>Precede the special character with a backslash \ to remove its special meaning.</strong></p>
  <p>e.g \. matches a literal dot, such as in "hello.world", \? matches a literal question mark, such as in "maybe?", \* matches a literal asterisk, such as in "a * b". </p>
</div>
<button class="collapsible">Matching a literal backslash when outside a set</button>
<div class="content">
  <p><strong>Use double backslashes \\  to escape the backslash, using a raw string (prefixed with “r”).</strong></p>
  <p>e.g. r’\\’ or r’[\\]’ matches “\” in “foo\bar”.
It’s good practice to use a raw string to specify a regular expression in Python whenever it contains backslashes.
</p>
</div>
<button class="collapsible">Making a character or set optional (any number of occurrences possible)</button>
<div class="content">
  <p><strong>Put an asterisk (*) behind the expression</strong></p>
  <p>e.g, a* matches zero or more “a” characters (“”, “a”, “aa”, “aaa”, …)
x*, \d*, \w*, … etc. can match a zero-length string or sequence(“”).</p>
</div>
<button class="collapsible">Making a character or set optional (zero or one occurrence possible)</button>
<div class="content">
  <p><strong>Put question mark (?) behind the expression</strong></p>
  <p>e.g. colou?r matches both “color” and “colour”,
defen[dcs]?[e]? matches “defend”, “defence” and “defense”.</p>
</div>
<button class="collapsible">Making a character or set a requirement for a match (one or more occurrences possible </button>
<div class="content">
  <p><strong>Put a plus sign (+) behind the expression
</strong></p>
  <p>e.g. \d+ matches one or more digits (9, 42, 321, …).</p>
</div>
<button class="collapsible">Getting the shortest possible match when using the *, +, ? quantifiers (non-greedy, or lazy behaviour)</button>
<div class="content">
  <p><strong>Put a question mark after the quantifier symbol: 
*?, +?, ??
</strong></p>
  <p>*, +, ? are “greedy”, trying to match the longest possible string, e.g. <.*> matches the whole string “&lt;p&gt;Hello World&lt;/p&gt;”, whereas  <.*?> matches “&lt;p&gt;”.
/d+ matches “123” but /d+? matches “1”.</p>
</div>
    <button class="collapsible">Specifying an exact number of repetitions of a character or set to be a match</button>
<div class="content">
  <p><strong>Put {m} after the expression</strong></p>
  <p>e.g. Xv{4}X matches “XvvvvX”.
</p>
</div>
<button class="collapsible">Specifying a min and max range of repetitions of a character or set to be a match</button>
<div class="content">
  <p><strong>Put {m, n} after the expression</strong></p>
  <p>e.g. \d{1, 3} matches numbers made of one up to three digits
{,n} is identical to {0,n}.</p>
</div>
<button class="collapsible">Specifying a minimum number of repetitions of a character or set to be a match (no upper limit)</button>
<div class="content">
  <p><strong>Put {m,} after the expression</strong></p>
  <p>{m,} means at least m times, 
{,} is identical to {0,} or *.</p>
</div>
<button class="collapsible">Getting the shortest possible match when using the {m, n} quantifiers (non-greedy, or lazy behaviour)</button>
<div class="content">
  <p><strong>Put a question mark after the expression:  {m,n}?</strong></p>
  <p>e.g.  X{3,5}?. 
{m,n} is “greedy”, trying to match the longest possible string.</p>
</div>
<button class="collapsible">Text required to be at the beginning of a string or of a new line to be a match</button>
<div class="content">
  <p><strong>Put the caret (^) anchor or \A in first position</strong></p>
  <p>e.g.  ^Once, \AOnce, ^!!. With re.match(), the caret (^) anchor is redundant. 
In a searching function using the re.MULTILINE flag, ^ matches both at the beginning of the string and at the beginning of any line within the string, but only at the beginning of the whole string without the flag. re.MULTILINE has no effect on \A.  re.M is shorthand for re.MULTILINE.</p>
</div>
<button class="collapsible">Text required to be at the end of a string or of a new line to be a match</button>
<div class="content">
  <p><strong>Put a dollar ($) anchor or \Z in last position</strong></p>
  <p>e.g.  time$, time\Z, \?$
In a searching function using the re.MULTILINE flag, $ matches both at the end of the string and at the end of any line within the string, but only at the end of the whole string without the flag. re.MULTILINE has no effect on \Z. re.M is shorthand for re.MULTILINE. </p>
</div>


<h2>Using groups for flexible matching</h2>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>

<h2>Looking for matches and extracting matches
</h2>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>

<h2>Fine-tuning search with flags
</h2>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>

<h2>Replacing and modifying parts of text
</h2>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>

<h2>Using the match objects returned by search functions
</h2>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>
<script src="script.js"></script>

</body>
</html>
