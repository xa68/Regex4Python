<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Reference guide for regular expressions in Python</title>
<link rel="stylesheet" href="./styles.css" />
</head>
<body>

<h1>Reference guide for regular expressions in Python</h1>
  
  <nav>
  <ul>
    <li><a href="#matching">Matching text patterns</a></li>
    <li><a href="#groups">Using groups for flexible matching</a></li>
    <li><a href="#search">Looking for matches and extracting matches</a></li>
    <li><a href="#flags">Fine-tuning search with flags</a></li>
    <li><a href="#sub">Replacing and modifying parts of text</a></li>
    <li><a href="#objects">Using the match objects returned by search functions </a></li>
  </ul>
</nav>

<h2 id='matching'>Matching text patterns</h2>
<button class="collapsible">Matching text literally</button>
<div class="content">
  <p><strong>Use a string literal (concatenate ordinary characters)</strong></p>
  <p>Case sensitive, e.g. reg matches “reg” in “regex”,  but not in “Regex”
The re.I (re.IGNORECASE) flag makes matching case-insensitive in a searching function.
</p>
</div>
<button class="collapsible">Matching any single alphanumeric character</button>
<div class="content">
  <p><strong>Use \w</strong></p>
  <p>\w is shorthand for [a-zA-Z0-9_]. 
\W is the opposite of \w, shorthand for [^a-zA-Z0-9_].
</p>
</div>
<button class="collapsible">Matching any single digit</button>
<div class="content">
  <p><strong>Use \d</strong></p>
  <p>\d is shorthand for [0-9]. \D is the opposite of \d, shorthand for [^0-9].</p>
</div>
<button class="collapsible">Matching a whitespace</button>
<div class="content">
  <p><strong>Use \s</strong></p>
  <p>\s is shorthand for [ \r\n\t\f\v]. \S is the opposite, matching what is not whitespace: [^ \r\n\t\f\v].</p>
</div>
<button class="collapsible">Matching any character</button>
<div class="content">
  <p><strong>. (dot) matches any single character (including a space), except the newline (\n) character</strong></p>
  <p>Using the  re.S (re.DOTALL) flag with a searching function forces the dot to match a new line character.
</p>
</div>
<button class="collapsible">Matching a character with a set of options</button>
<div class="content">
  <p><strong>Put the set of matching options in square brackets: [...].
Any of the characters enclosed within the square brackets [ ] is a matching option for a single character from the input text.
</strong></p>
  <p>e.g. defen[cs]e matches both “defence” and “defense”. 
[^...] is the opposite, matching anything but what is in the set e.g <[^>]> matches an html tag with any content. 
An hyphen (-) can indicate a range of characters in a set e.g. [a-fA-F], [0-5].
</p>
</div>
<button class="collapsible">Matching a literal hyphen literally when in a set
</button>
<div class="content">
  <p><strong>Place the hyphen in first or last position in the set, or escape it.
</strong></p>
  <p>e.g. [-abc], [abc-], [ab\-c].</p>
</div>
<button class="collapsible">Matching a special character literally when in a set</button>
<div class="content">
  <p><strong>Special characters lose their special meaning inside sets.</strong></p>
  <p>e.g. the special characters in the set [().,*+?|] match themselves literally.</p>
</div>
<button class="collapsible">Matching a special character literally when outside a set</button>
<div class="content">
  <p><strong>Precede the special character with a backslash \ to remove its special meaning.</strong></p>
  <p>e.g \. matches a literal dot, such as in "hello.world", \? matches a literal question mark, such as in "maybe?", \* matches a literal asterisk, such as in "a * b". </p>
</div>
<button class="collapsible">Matching a literal backslash when outside a set</button>
<div class="content">
  <p><strong>Use double backslashes \\  to escape the backslash, using a raw string (prefixed with “r”).</strong></p>
  <p>e.g. r’\\’ or r’[\\]’ matches “\” in “foo\bar”.
It’s good practice to use a raw string to specify a regular expression in Python whenever it contains backslashes.
</p>
</div>
<button class="collapsible">Making a character or set optional (any number of occurrences possible)</button>
<div class="content">
  <p><strong>Put an asterisk (*) behind the expression</strong></p>
  <p>e.g, a* matches zero or more “a” characters (“”, “a”, “aa”, “aaa”, …)
x*, \d*, \w*, … etc. can match a zero-length string or sequence(“”).</p>
</div>
<button class="collapsible">Making a character or set optional (zero or one occurrence possible)</button>
<div class="content">
  <p><strong>Put question mark (?) behind the expression</strong></p>
  <p>e.g. colou?r matches both “color” and “colour”,
defen[dcs]?[e]? matches “defend”, “defence” and “defense”.</p>
</div>
<button class="collapsible">Making a character or set a requirement for a match (one or more occurrences possible </button>
<div class="content">
  <p><strong>Put a plus sign (+) behind the expression
</strong></p>
  <p>e.g. \d+ matches one or more digits (9, 42, 321, …).</p>
</div>
<button class="collapsible">Getting the shortest possible match when using the *, +, ? quantifiers (non-greedy, or lazy behaviour)</button>
<div class="content">
  <p><strong>Put a question mark after the quantifier symbol: 
*?, +?, ??
</strong></p>
  <p>*, +, ? are “greedy”, trying to match the longest possible string, e.g. <.*> matches the whole string “&lt;p&gt;Hello World&lt;/p&gt;”, whereas  <.*?> matches “&lt;p&gt;”.
/d+ matches “123” but /d+? matches “1”.</p>
</div>
    <button class="collapsible">Specifying an exact number of repetitions of a character or set to be a match</button>
<div class="content">
  <p><strong>Put {m} after the expression</strong></p>
  <p>e.g. Xv{4}X matches “XvvvvX”.
</p>
</div>
<button class="collapsible">Specifying a min and max range of repetitions of a character or set to be a match</button>
<div class="content">
  <p><strong>Put {m, n} after the expression</strong></p>
  <p>e.g. \d{1, 3} matches numbers made of one up to three digits
{,n} is identical to {0,n}.</p>
</div>
<button class="collapsible">Specifying a minimum number of repetitions of a character or set to be a match (no upper limit)</button>
<div class="content">
  <p><strong>Put {m,} after the expression</strong></p>
  <p>{m,} means at least m times, 
{,} is identical to {0,} or *.</p>
</div>
<button class="collapsible">Getting the shortest possible match when using the {m, n} quantifiers (non-greedy, or lazy behaviour)</button>
<div class="content">
  <p><strong>Put a question mark after the expression:  {m,n}?</strong></p>
  <p>e.g.  X{3,5}?. 
{m,n} is “greedy”, trying to match the longest possible string.</p>
</div>
<button class="collapsible">Text required to be at the beginning of a string or of a new line to be a match</button>
<div class="content">
  <p><strong>Put the caret (^) anchor or \A in first position</strong></p>
  <p>e.g.  ^Once, \AOnce, ^!!. With re.match(), the caret (^) anchor is redundant. 
In a searching function using the re.MULTILINE flag, ^ matches both at the beginning of the string and at the beginning of any line within the string, but only at the beginning of the whole string without the flag. re.MULTILINE has no effect on \A.  re.M is shorthand for re.MULTILINE.</p>
</div>
<button class="collapsible">Text required to be at the end of a string or of a new line to be a match</button>
<div class="content">
  <p><strong>Put a dollar ($) anchor or \Z in last position</strong></p>
  <p>e.g.  time$, time\Z, \?$
In a searching function using the re.MULTILINE flag, $ matches both at the end of the string and at the end of any line within the string, but only at the end of the whole string without the flag. re.MULTILINE has no effect on \Z. re.M is shorthand for re.MULTILINE. </p>
</div>
    <button class="collapsible"> Text required to be at the beginning of words to be a match (such as prefixes) </button>
<div class="content">
  <p><strong>Put \b in front of the expression</strong></p>
  <p>e.g. \breg\w+ matches words starting with “reg” such as “regular”.
\B is the opposite: matching patterns within or at the end of words, such as hyphens or slashes.
</p>
</div>
<button class="collapsible">Text required to be at the end of words to be match (such as suffixes)</button>
<div class="content">
  <p><strong>Put \b behind the expression</strong></p>
  <p>e.g. \w+ly\b matches words ending with “ly” such as “truly”.
\B is the opposite:  matching patterns at the start or within words, such as hyphens or slashes.</p>
</div>
<button class="collapsible">Text required to be within words to be a match</button>
<div class="content">
  <p><strong>\B is the opposite of \b</strong></p>
  <p>e.g \Bper\B will match “per” only if it appears within a larger word as in “operate”(not at the beginning or end of a word as in “per” or “super”). Useful for matching patterns within words or sequences, such as hyphens or slashes.
</p>
</div>
<button class="collapsible">Automatically adding backslashes in an expression to escape special characters</button>
<div class="content">
  <p><strong>Use the re.escape() method</strong></p>
  <p>re.escape() saves you the trouble of putting in all the backslashes manually when you have many special characters that must be matched literally. It returns a copy of the expression with each nonword character (anything other than a letter, digit, or underscore) preceded by a backslash e.g. re.escape('red^green(blue)|yellow') returns the expression string 'red\^green\(blue\)\|yellow' , and re.search(re.escape('red^green(blue)|yellow'), 'red^green(blue)|yellow') matches  'red^green(blue)|yellow' literally. </p>
</div>
<button class="collapsible">Specify a set of alternatives on which to match</button>
<div class="content">
  <p><strong>Insert the pipe character | between the alternative expressions</strong></p>
  <p>e.g. [0-9]+|[a-f]+ means one or more digits, or one or more smallcaps from a to f.
Alternation is non-greedy: stops when the first match is found, looking at the expressions from left to right e.g. re.search('a|b|c', 'abc') matches “a”. </p>
</div>

<h2 id='groups'>Using groups for flexible matching</h2>
<button class="collapsible">Creating subexpressions for specific pattern matching</button>
<div class="content">
  <p><strong>Put in the subexpression in parentheses: (...)
</strong></p>
  <p>The characters in the parentheses make a group to which specific matching rules can apply within a larger expression, e.g,. in abc+ the metacharacter ‘+’ applies only to “c”, while in (abc)+ it applies to the entire string “abc”.
You can nest groups e.g. (abc(123)?)+ 
</p>
</div>
<button class="collapsible">Using groups in expressions to capture the matched elements</button>
<div class="content">
  <p><strong>Parentheses create capture groups, storing the matched text for later reference</strong></p>
  <p>e.g. ((0\d)([.](\d{2})){4}) matches 10-digit phone numbers in the format 01.23.45.67.89</p>
</div>
<button class="collapsible">Checking that a certain pattern comes after (positive lookahead)</button>
<div class="content">
  <p><strong>For a positive lookahead, put ?= in first position inside the group: (?=...)
</strong></p>
  <p> e.g. ABC(?=[A-Z0-9]{5}) matches “ABC” if it is immediately followed by 5 uppercase letters or digits such as "ABC1A2B3"</p>
</div>
<button class="collapsible">Checking that a certain pattern immediately follows (positive lookahead)</button>
<div class="content">
  <p><strong>For a positive lookahead, put ?= in first position inside the group: (?=...)</strong></p>
  <p>e.g. ABC(?=[A-Z0-9]{5}) matches “ABC” if it is immediately followed by 5 uppercase letters or digits such as "ABC1A2B3"</p>
</div>
<button class="collapsible">Checking that a certain pattern does not immediately follow (negative lookahead)</button>
<div class="content">
  <p><strong>For a negative lookahead, put ?! in first position inside the group: (?!...)</strong></p>
  <p>e.g. play(?!\s+the) matches “play” if it is not followed by “ the”, as in  “played the piano”</p>
</div>
<button class="collapsible">Checking that a certain pattern comes immediately before (positive lookbehind)</button>
<div class="content">
  <p><strong>For a positive lookbehind, put ?&lt;= in first position inside the group: (?&lt;=...)
</strong></p>
  <p>e.g. (?&lt;=geo)metric matches “metric” if it is preceded by “geo”, but does not match with “isometric” or “parametric”
</p>
</div>
<button class="collapsible">Checking that a certain pattern does not come immediately before (negative lookbehind)</button>
<div class="content">
  <p><strong>For a negative lookbehind, put ?&lt;! in first position inside the group: (?&lt;!...)</strong></p>
  <p>e.g. (?&lt;!grand\s)total will match “total” if it is  not preceded by “grand ”,  as in “total” or “subtotal”</p>
</div>
<button class="collapsible">Creating a non-capturing group (matched text is not stored)</button>
<div class="content">
  <p><strong>Put ?: in first position inside the group: (?:...)</strong></p>
  <p>e.g. (?:[Mm]adam|[Ss]ir) 
Useful when matching on alternatives or required patterns, without the need to capture the text. 
Can improve efficiency by reducing processing and memory usage.</p>
</div>
<button class="collapsible">Referencing matched text by order of capture</button>
<div class="content">
  <p><strong>Put \n after the expression, where n is the nth captured match</strong></p>
  <p>e.g.  (\w+)-\1 matches a sequence of word characters, followed by a hyphen, immediately followed by the same sequence (first capture).
Useful for finding repeated words such as “the the”, or extracting repeated sequences such as matching word pairs.</p>
</div>
<button class="collapsible">Naming a group for backreference by name</button>
<div class="content">
  <p><strong>To name a group: put ?P and the group’s name in angle brackets in first position inside the group: (?P<name>...). 
To back-reference to the named group, put ?P= and the name of the group in first position in a separate group: (?P=name...)</strong></p>
  <p>e.g. (?P&lt;w1&gt;\w+),(?P&lt;w2&gt;\w+) gives m.group('w1'), m.group('w2'), m.group('w1', 'w2'), with m being the returned match object. 
The angle brackets (&lt; and &gt;) are required around name when creating a named group but not when referring to it later e.g. (?P&lt;num&gt;\d+)\.(?P=num) matches a sequence of digits, followed by a literal dot, followed by the same sequence of digits again.
Useful for finding repeated sequences or checking that two words or numbers are identical.
</p>
</div>
<button class="collapsible">Choosing between two alternatives expressions, depending on a third (if-then-else logic)</button>
<div class="content">
  <p><strong>Following the expression acting as the condition, add a group having in first position  ?(n), if using an unnamed conditional group, or ?(name), if named, followed  by the two alternative expressions separated by the pipe character |</strong></p>
  <p>The group will use the first alternative to find a match if the conditional expression itself found a match, otherwise it will use the second alternative, e.g.  ^(##)?(?(1)RefA|RefB) matches “##RefA” if “##” is found at the beginning of the text, otherwise matches "RefB ". 
Here is the same example, using a named group: ^(?P<sh>##)?(?(sh)typeA|typeB)</p>
</div>
<button class="collapsible">Adding comments inside a regular expression</button>
<div class="content">
  <p><strong>Put ?# in first position inside the group </strong></p>
  <p>Anything contained in the sequence (?#...) is ignored by the regex parser. e.g. ^(##)?(?# this is a comment)\W+'</p>
</div>

<h2 id='search'>Looking for matches and extracting matches
</h2>
<button class="collapsible">Scanning a string for a match</button>
<div class="content">
  <p><strong>Use re.search()</strong></p>
  <p>e.g. re.search(r'fox', 'the brown fox')
The re.search() function searches for the first occurrence of the pattern within the string, returning a match object if it finds a match, and None otherwise.</p>
</div>
<button class="collapsible">Specifying a range in the input string that limits where to look for matches</button>
<div class="content">
  <p><strong>Pass the pos and endpos optional arguments to the search() method, called on a compiled expression object</strong></p>
  <p>e.g.  re_obj = re.compile(r'\d+'); 
m = re_obj.search('red123green', 2, 7); 
m gives match='123'; 
m.pos, m.endpos gives (2, 7). 
Specifying only  <pos> and omitting <endpos>, the search applies to the substring from <pos> to the end of the string eg re_obj.search(s, 6). 
Anchors such as caret (^) or \A and  dollar sign ($) or \Z still refer to the start and end of the entire input string, not the substring delimited by pos and endpos.</p>
</div>
<button class="collapsible">Getting the start and end index locations of the effective range used in the input string</button>
<div class="content">
  <p><strong>Use the m.pos and m.endpos attributes, with m being the match object</strong></p>
  <p>m.pos and m.endpos are respectively the  start and end index locations of the effective range used in the input string (whole string or a slice given by the pos and endpos parameters) e.g. re_obj = re.compile(r'\d+'); m = re_obj.search('red123green', 2, 7); m gives match='123'; m.pos, m.endpos gives (2, 7)</p>
</div>
<button class="collapsible">Looking for a match only at the beginning of the string</button>
<div class="content">
  <p><strong>Use re.match()</strong></p>
  <p>e.g. re.match(r'the, 'the lowercase').
With re.match(), the caret (^) and /A anchors are redundant.</p>
</div>
<button class="collapsible">Looking for a match of the entire string (full match)</button>
<div class="content">
  <p><strong>Use re.fullmatch()</strong></p>
  <p>re.fullmatch() returns a match only if the expression matches  the input string in its entirety, and returns None otherwise, eg re.fullmatch(r'\d{2}-\d{2}-\d{4}’, '12-07-2023')</p>
</div>
<button class="collapsible">Getting a list of all (non-overlapping) matches</button>
<div class="content">
  <p><strong>Use re.findall()</strong></p>
  <p>re.findall() returns a list of all non-overlapping matches from the input string.  It scans the string from left to right and returns all non-overlapping matches in the order found e.g. re.findall(r'\d+', '123, 42, and 6789') returns ['123', '42', '6789']. 
If the expression contains a capturing group, then the return list contains only the match for the group, not the entire match e.g  re.findall(r'(#[a-z]+) [\w\s]* !![a-z]+', '#this and also !!that')  returns  ['#this']. 
Use findall() on  a compiled expression object if you need to limit the range of the input string where to look for matches  e.g. 
re_obj = re.compile(r'\d+')
m = re_obj.findall('r12g34b56', 4, 9)
m gives ['34', '56']
m.pos, m.endpos gives (4, 9)</p>
</div>
<button class="collapsible">Getting an iterator of all match objects</button>
<div class="content">
  <p><strong>Use re.finditer()</strong></p>
  <p>re.finditer() scans the input string for non-overlapping matches of the given pattern and returns an iterator that yields the match objects from any it finds, scanning the string from left to right and returning in the order it finds them.
Call finditerl() on  a compiled expression object if there is need to limit the range of the input string where to look for matches e.g.
re_obj = re.compile(r'\d+')
m = re_obj.finditer('r12g34b56', 4, 9)</p>
</div>


<h2 id='flags'>Fine-tuning search with flags
</h2>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>

<h2 id='sub'>Replacing and modifying parts of text
</h2>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>

<h2 id='objects'>Using the match objects returned by search functions
</h2>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>
<button class="collapsible">text</button>
<div class="content">
  <p><strong>text</strong></p>
  <p>text</p>
</div>
<script src="script.js"></script>

</body>
</html>
